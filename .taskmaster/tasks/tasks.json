{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initial Chrome Extension Project Setup",
        "description": "Set up the basic structure for the Google Chrome extension, including the manifest.json file, background scripts, content scripts, and popup HTML/CSS/JS files. This foundational step enables all subsequent development.",
        "details": "Create a `manifest.json` (version 3) defining permissions like `storage`, `activeTab`, and `scripting`. Set up host permissions for `*://*.linkedin.com/*`, `*://*.indeed.com/*`, etc. Create placeholder files: `popup.html`, `popup.js`, `background.js`, and a `content_scripts` directory. Use a modern frontend framework like React or Vue for the popup UI, or start with vanilla JS for simplicity. Initialize a Git repository.",
        "testStrategy": "Load the unpacked extension in Chrome. Verify that the popup window opens when the extension icon is clicked and that the background script logs a message to its console on startup. Ensure no errors appear in the extension management page.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Secure User Profile Data Storage",
        "description": "Implement secure storage for user profile data, including personal information, work experience, education, and skills. This data will be the single source of truth for all extension features.",
        "details": "Use `chrome.storage.local` for storing user data. Define a clear JSON schema for the user profile object, e.g., `{ personalInfo: { name, email, phone }, experience: [{...}], education: [{...}], skills: [...] }`. Create a service module (`storageService.js`) with functions like `getUserProfile()`, `saveUserProfile(data)`, and `updateProfileField(key, value)` to abstract storage operations. All sensitive data should be handled carefully, ensuring it doesn't leak into browser logs.",
        "testStrategy": "Use the extension's background script console to call the service module functions. Save a sample profile object, retrieve it, and assert that the retrieved data matches the saved data. Verify that data persists after closing and reopening the browser.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop Profile Management UI",
        "description": "Create the user interface for the profile management page. This allows users to manually input and edit their professional details, which will be used for auto-filling applications.",
        "details": "In `popup.html`, design a form with input fields for all properties defined in the user profile schema (Task 2). This includes sections for personal details, and dynamic lists for work experience and education where users can add or remove entries. On input change, automatically save the data using the `storageService.js`. Populate the form with existing data when the popup is opened.",
        "testStrategy": "Open the extension popup. Manually fill in all fields. Close and reopen the popup to ensure all data is correctly loaded and displayed. Edit a field and verify the change is persisted. Test adding and removing items from dynamic lists like work experience.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Resume Parsing for Profile Population",
        "description": "Implement functionality to parse uploaded resumes in PDF and DOCX formats and use the extracted text to pre-fill the user's profile form.",
        "details": "Add a file input (`<input type=\"file\" accept=\".pdf,.docx\">`) to the profile UI. Use client-side libraries to handle parsing: `pdf-js-dist` for PDFs and `mammoth.js` for DOCX. When a file is uploaded, read its content and extract structured information (e.g., using regex or simple heuristics to find sections like 'Experience', 'Education', 'Skills'). Populate the corresponding fields in the profile UI for the user to review and save.",
        "testStrategy": "Upload various sample resumes in both PDF and DOCX formats. Verify that text is extracted successfully. Check if the profile fields (name, email, job titles, etc.) are populated with reasonable accuracy. Ensure the UI handles parsing errors gracefully.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Content Script for Application Form Detection",
        "description": "Develop a content script that can be injected into supported job platforms to detect and identify application form fields.",
        "details": "Configure the `manifest.json` to inject a content script (`formDetector.js`) into pages matching application URLs on LinkedIn, Indeed, etc. The script will scan the DOM for `<form>` elements and common input field selectors (e.g., `input[name*='name']`, `textarea[id*='experience']`, `[aria-label*='phone']`). Create a mapping configuration that defines selectors for each supported site.",
        "testStrategy": "Navigate to job application pages on LinkedIn and Indeed. Verify the content script is injected. Use `console.log` to output the detected form fields to the browser's developer console. Manually check if key fields like 'First Name', 'Email', and 'Resume Upload' are correctly identified.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Automated Form Filling Logic",
        "description": "Implement the core logic to automatically fill detected form fields with data from the user's stored profile.",
        "details": "The content script will message the background script to fetch the user profile from `chrome.storage`. Upon receiving the data, it will iterate through the detected form fields and populate them with the corresponding profile information. For example, `document.querySelector('#firstName').value = userProfile.personalInfo.firstName`. Add a small delay between filling fields to mimic human behavior and avoid bot detection.",
        "testStrategy": "With a pre-filled user profile, navigate to a job application page. Trigger the auto-fill process (e.g., via a button injected by the content script). Verify that all corresponding form fields are populated correctly with the data from the user profile. Test on multiple job postings on each supported platform.",
        "priority": "high",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop UI for Triggering and Reviewing Auto-Fill",
        "description": "Create a UI element, such as a floating button or a banner, that allows the user to trigger, review, and confirm the auto-filled information before submission.",
        "details": "The content script will inject a floating button (e.g., with the extension's logo) onto the page when an application form is detected. Clicking this button initiates the auto-fill process. After filling, the script can highlight the modified fields with a colored border. The UI should clearly state that the form has been filled and that the user should review it.",
        "testStrategy": "Navigate to an application page. Confirm the 'Auto-fill' button appears. Click it and verify fields are filled and highlighted. Manually edit a highlighted field and ensure the change is not overwritten. The button's state should update (e.g., to 'Filled') after the action.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate with an LLM API Service",
        "description": "Set up a secure service to communicate with a Large Language Model (LLM) API for content generation tasks. This includes managing API keys securely.",
        "details": "Create a module in the background script (`llmService.js`). This service will have a function, e.g., `generateContent(prompt)`, that uses the `fetch` API to make POST requests to an LLM provider (e.g., OpenAI, Google AI). The user's API key will be stored securely using `chrome.storage.local` after being entered in the extension's settings page. The service must handle API errors and rate limits.",
        "testStrategy": "In the extension's settings, add an input for the LLM API key and save it. From the background script console, call the `generateContent` function with a simple prompt like 'say hello'. Verify that a successful 200 OK response is received from the LLM API and the content is returned.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Job Description Scraping",
        "description": "Enhance the content script to accurately scrape the full job title and description from the job posting page.",
        "details": "The content script will use site-specific selectors to find and extract the text content of the job title and the main job description block. This data is crucial context for the LLM. The script should clean the extracted text by removing unwanted HTML tags and whitespace. This information will be temporarily stored or passed directly to the background script when needed.",
        "testStrategy": "Navigate to several job pages on each supported platform. Use the developer console to trigger the scraping function and log the extracted job title and description. Manually compare the output with the page content to ensure accuracy and completeness.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement AI-Powered Answer Generation",
        "description": "Leverage the LLM to generate tailored answers for open-ended questions on application forms, based on the user's profile and the job description.",
        "details": "The content script will identify open-ended question fields (e.g., `<textarea>`). It will inject a 'Generate Answer' button next to them. On click, it will send the question text (e.g., from the `label`), the scraped job description, and the user's profile to the `llmService`. The prompt will be structured like: 'Based on my profile (profile...) and the job description (job...), answer this question: (question...)'. The generated text is then inserted into the textarea.",
        "testStrategy": "Find an application with a question like 'Why are you a good fit for this role?'. Click the 'Generate Answer' button. Verify that the LLM-generated response is relevant, uses information from both the profile and job description, and is inserted into the correct field.",
        "priority": "high",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement AI-Powered Cover Letter Generation",
        "description": "Create a feature to generate a custom cover letter based on the job description and the user's profile.",
        "details": "Add a 'Generate Cover Letter' button to the extension's main popup UI. When on a job page, clicking this button will trigger the `llmService`. The service will be called with a prompt combining the user's full profile and the scraped job description, asking it to write a professional cover letter. The generated text will be displayed in a modal or new tab, with options to copy or save.",
        "testStrategy": "Navigate to a job posting. Open the extension popup and click 'Generate Cover Letter'. Review the generated letter for quality, relevance, and personalization. It should clearly reference the user's skills/experience and the requirements in the job description.",
        "priority": "medium",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Develop Extension Dashboard UI",
        "description": "Design and build the main dashboard UI for the extension's popup, serving as the central hub for all features.",
        "details": "Develop the main view for `popup.html`. This dashboard should provide clear navigation to different sections: 'Profile', 'Recommended Jobs', 'Application History', and 'Settings'. It should have a clean, intuitive layout that presents key information at a glance. This is the primary user interaction point, so usability is key.",
        "testStrategy": "Open the extension popup. Verify that the dashboard layout is rendered correctly. Test navigation between the different sections/tabs. The UI should be responsive and visually appealing.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement AI Job-to-Profile Relevance Analysis",
        "description": "Implement the logic to analyze a job description against the user's profile and determine a relevance score.",
        "details": "Create a function that can be triggered from the content script. This function sends the user's profile (skills, experience titles) and the scraped job description to the LLM service. The prompt will ask the LLM to act as a recruiter, compare the two, and return a relevance score (e.g., 1-100) and a brief summary of why it's a match or not. This logic will power the job recommendations.",
        "testStrategy": "Manually trigger the analysis function with a known good-fit job and a known bad-fit job. Check the returned score and summary. The good fit should have a high score and relevant summary, while the bad fit should have a low score.",
        "priority": "medium",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Display AI-Powered Job Recommendations",
        "description": "Display a list of recommended jobs within the extension's dashboard, ranked by the AI-driven relevance score.",
        "details": "This feature requires a mechanism to discover jobs (e.g., by scraping a search results page or analyzing jobs the user clicks on). For each discovered job, run the relevance analysis (Task 13). Store the job title, link, and relevance score in `chrome.storage`. The 'Recommended Jobs' section of the dashboard will fetch and display this list, sorted from highest to lowest relevance.",
        "testStrategy": "Browse a job search results page. Verify that the extension identifies multiple jobs and analyzes them. Open the dashboard and check the 'Recommended Jobs' list. The jobs should be present and correctly ranked by their relevance score.",
        "priority": "low",
        "dependencies": [
          12,
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Application Tracking",
        "description": "Implement a system to track the jobs a user has applied to using the extension, storing the job title, company, and date applied.",
        "details": "After a user successfully uses the auto-fill feature and a form submission is detected (e.g., by observing a URL change to a 'success' page or the submit button disappearing), the content script will prompt the user: 'Track this application?'. If confirmed, the job title, company, URL, and current date are saved to a dedicated list in `chrome.storage.local`.",
        "testStrategy": "Apply to a job using the auto-fill feature. On the confirmation page, ensure the 'Track this application?' prompt appears. Click 'Yes' and then check `chrome.storage` via the background console to confirm the application details were saved correctly.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Develop UI for Application History",
        "description": "Create a UI section within the dashboard to display the list of jobs the user has applied for.",
        "details": "Add an 'Application History' tab or section to the dashboard UI. This section will fetch the list of tracked applications from `chrome.storage` and display it in a clear, reverse chronological list. Each entry should show the job title, company, and date applied, and include a link to the original job posting.",
        "testStrategy": "After tracking several applications, open the dashboard and navigate to the 'Application History' section. Verify that all tracked jobs are listed correctly with the right information and in the correct order. Test that the links navigate to the correct job pages.",
        "priority": "medium",
        "dependencies": [
          12,
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create Extension Settings Page",
        "description": "Create a settings page within the extension where users can manage their LLM API key and other preferences.",
        "details": "Build a 'Settings' view accessible from the main dashboard. This page will include an input field for the user to enter and save their LLM API key. It should also include toggles for enabling/disabling major features like auto-fill or AI recommendations. All settings will be saved to `chrome.storage.local`.",
        "testStrategy": "Navigate to the settings page. Enter an API key and save it. Close and reopen the popup, return to settings, and verify the key is still there (masked, e.g., `sk-****...1234`). Toggle a feature off, and confirm that the corresponding functionality is disabled.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Ensure Cross-Platform Compatibility",
        "description": "Systematically test and refine content scripts to ensure compatibility and correct functionality across all supported job platforms: LinkedIn, Indeed, Glassdoor, and ZipRecruiter.",
        "details": "Create a testing checklist for each platform. For each site, test: 1. Form detection. 2. Auto-fill accuracy. 3. Job description scraping. 4. AI answer generation button injection. This will likely require creating site-specific selector maps and logic to handle variations in page structure. Update the `host_permissions` in the manifest as needed.",
        "testStrategy": "Go through a full application flow on at least two different job postings on each of the four target platforms. Document any failures or incorrect behavior in a bug tracking system. The task is complete when all core features work reliably on all supported sites.",
        "priority": "high",
        "dependencies": [
          6,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Security Audit and Hardening",
        "description": "Conduct a thorough review of data handling and storage practices to ensure all user data is secure. This includes encrypting sensitive information where necessary.",
        "details": "Review all `chrome.storage` usage. While `chrome.storage` is sandboxed, consider adding a layer of client-side encryption for the LLM API key before storing it. Use a library like `crypto-js`. Ensure all communication with external APIs (the LLM) uses HTTPS. Sanitize any data displayed in the UI to prevent XSS attacks.",
        "testStrategy": "Perform a code review focused on security. Check network requests in the browser's developer tools to ensure they use HTTPS. Manually inspect the contents of `chrome.storage` to confirm sensitive data like API keys are not stored in plaintext. Attempt to inject scripts into profile fields to test for XSS vulnerabilities.",
        "priority": "high",
        "dependencies": [
          2,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Performance Optimization",
        "description": "Analyze and optimize the extension's performance to ensure it does not slow down the user's browsing experience. Focus on lightweight content scripts and responsive AI generation.",
        "details": "Use the Chrome DevTools Performance profiler to measure the impact of content scripts on page load and interactivity. Optimize DOM scanning by using efficient selectors and avoiding frequent, heavy computations on the main thread. For AI features, ensure the UI shows a loading state immediately so the user knows something is happening, preventing the perception of a frozen page.",
        "testStrategy": "With the extension enabled, browse the supported job sites and measure page load times and CPU usage, comparing them to browsing with the extension disabled. The difference should be negligible. Time how long it takes for AI-generated content to appear after clicking the button; it should be within a few seconds.",
        "priority": "medium",
        "dependencies": [
          6,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Create Extension Icons and Visual Assets",
        "description": "Design and create all necessary visual assets for the extension, including icons for the toolbar, the Chrome Web Store, and any images used within the UI.",
        "details": "Create a main extension logo. Generate a set of icons in required sizes (16x16, 32x32, 48x48, 128x128) for the `manifest.json`. Design any other icons or simple illustrations needed for the dashboard UI to improve usability. Ensure all assets are optimized for size.",
        "testStrategy": "Load the extension with the new icons. Verify the toolbar icon is clear and correctly sized. Check that all icons within the UI are displayed properly. Ensure the 128x128 icon looks good on the extension management page.",
        "priority": "low",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Package and Prepare for Chrome Web Store Submission",
        "description": "Prepare the extension for submission to the Chrome Web Store, including creating the final packaged file, writing a description, taking screenshots, and drafting a privacy policy.",
        "details": "Write a compelling description for the Chrome Web Store listing, highlighting the key benefits (time-saving, AI-powered). Take high-quality screenshots of the extension in action (e.g., profile page, auto-filling a form, AI-generated answer). Draft a clear privacy policy explaining what data is collected and how it is used and stored. Package the extension into a .zip file for upload.",
        "testStrategy": "Review the generated package and store listing materials against the Chrome Web Store developer guidelines. Have a peer read the description and privacy policy for clarity. The task is complete when the .zip file and all marketing assets are ready for upload.",
        "priority": "high",
        "dependencies": [
          18,
          19,
          20,
          21
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 23,
        "title": "Enhance Resume Parsing with LLM for Profile Extraction",
        "description": "Replace the existing heuristic-based resume parsing with an LLM-powered service to accurately extract structured user profile data from uploaded resumes. This will significantly improve the quality of auto-populated profiles.",
        "details": "Modify the existing resume upload functionality from Task 4. After extracting the raw text from the PDF or DOCX file, send the text to the pre-configured LLM service. Develop a detailed prompt that instructs the LLM to act as an expert HR data extractor and return a JSON object that strictly adheres to the user profile schema defined in Task 2. The function handling the LLM API call should manage the request and parse the JSON response, with robust error handling for API failures or malformed data. On success, use the structured JSON to populate the Profile Management UI from Task 3 for user review. Ensure the LLM API key is handled securely per the practices in Task 19.",
        "testStrategy": "Upload several sample resumes in both PDF and DOCX formats with varying layouts. Verify that the profile form is populated accurately with all data, including nested job experiences and education. Confirm the extracted data structure matches the schema from Task 2. Test with an empty or unparsable file and verify a user-friendly error is shown. Simulate an LLM API failure (e.g., invalid key) to confirm graceful error handling. Compare the quality of the LLM-extracted data against the previous method to confirm improvement.",
        "status": "done",
        "dependencies": [
          2,
          3,
          4,
          13,
          19
        ],
        "priority": "medium",
        "subtasks": [
          {
            "id": 1,
            "title": "Design and Develop the LLM Prompt for Profile Extraction",
            "description": "Create a detailed and robust prompt for the LLM. The prompt must instruct the LLM to act as an expert HR data extractor and return a JSON object that strictly adheres to the user profile schema defined in Task 2.",
            "dependencies": [],
            "details": "The prompt engineering phase is critical. It involves iterating on prompt versions to handle various resume formats and edge cases. The prompt must explicitly define the desired JSON structure, data types, and rules for handling missing information (e.g., using null values or empty arrays). It should directly reference the schema from Task 2 to ensure consistency.",
            "status": "done",
            "testStrategy": "Test the prompt with at least 10 different sample resume texts (covering different formats, industries, and experience levels) using an LLM playground or a simple script. Validate that the output JSON is always well-formed and accurately reflects the input text according to the schema."
          },
          {
            "id": 2,
            "title": "Implement the LLM API Integration Service",
            "description": "Develop a backend service or module responsible for communicating with the configured LLM API. This service will encapsulate the logic for sending the resume text and prompt, handling authentication securely, and receiving the raw response.",
            "dependencies": [
              1
            ],
            "details": "This service will contain a primary function that accepts raw resume text as input. It must securely retrieve the LLM API key following the practices from Task 19 (e.g., from a secrets manager or environment variables). It will then construct the API request payload, including the prompt from subtask 1 and the resume text, and send it to the LLM endpoint.",
            "status": "done",
            "testStrategy": "Unit test the service by mocking the LLM API. Verify that it correctly constructs the request payload, adds the necessary authentication headers, and correctly handles both successful (2xx) and error (4xx, 5xx) HTTP status codes from the mock API."
          },
          {
            "id": 3,
            "title": "Develop a Robust LLM Response Parser and Validator",
            "description": "Create a component to parse the JSON response from the LLM API. This must include comprehensive error handling for API failures, network issues, and malformed or incomplete JSON data returned by the LLM.",
            "dependencies": [
              2
            ],
            "details": "The parser will attempt to decode the JSON string from the LLM's response. It must then validate the parsed object against the expected user profile schema (from Task 2). Implement retry logic with exponential backoff for transient API errors (e.g., 503 Service Unavailable). If parsing or validation fails, it should log the error and return a standardized error object to the calling function.",
            "status": "done",
            "testStrategy": "Unit test the parser with a variety of string inputs: a perfect JSON response, JSON with missing fields, a non-JSON string, an empty string, and null. Also, simulate various API error responses to ensure the error handling and retry logic are triggered correctly."
          },
          {
            "id": 4,
            "title": "Integrate LLM Service into the Resume Upload Workflow",
            "description": "Modify the existing resume upload controller/handler (from Task 4) to replace the old heuristic parsing logic. The new workflow will orchestrate the text extraction and the call to the new LLM integration service.",
            "dependencies": [
              3
            ],
            "details": "Refactor the backend endpoint that handles file uploads. After the existing logic extracts raw text from the uploaded PDF or DOCX file, it will now pass this text to the LLM API Integration Service (Subtask 2). The endpoint must wait for the structured JSON response from the parser (Subtask 3) and pass this data back to the client upon success, or an error message upon failure.",
            "status": "done",
            "testStrategy": "Write an integration test for the upload endpoint. Upload a sample resume file and mock the LLM service (Subtasks 2 & 3) to return a predefined successful JSON object. Verify the endpoint returns a 200 status with the correct JSON payload. Then, mock an error state and verify the endpoint returns the appropriate error code and message."
          },
          {
            "id": 5,
            "title": "Populate Profile UI with Extracted Data for User Review",
            "description": "On a successful response from the backend, use the structured JSON data to populate the fields in the Profile Management UI (from Task 3), allowing the user to review and edit the information.",
            "dependencies": [
              4
            ],
            "details": "The frontend component for the Profile Management UI will be updated to handle the JSON payload from the resume upload endpoint. A mapping function will be created to iterate through the received JSON and populate the corresponding form fields (e.g., personal info, work experience, education). The form should be rendered in a 'review' state, clearly indicating which data was auto-populated.",
            "status": "done",
            "testStrategy": "Conduct an end-to-end test. As a user, upload a resume. Verify that after processing, the profile page is displayed and all relevant fields (name, contact, experience, etc.) are correctly populated with the data extracted from the resume. Test with a resume that has missing sections to ensure the UI handles empty or null data gracefully."
          }
        ]
      },
      {
        "id": 24,
        "title": "Implement Passcode Lock for Extension Access",
        "description": "Implement a passcode lock screen that appears whenever the user opens the extension popup after a configurable delay. This feature will enhance user privacy by protecting the sensitive profile and application data stored within the extension, while providing flexibility for the user.",
        "status": "done",
        "dependencies": [
          1,
          12,
          17,
          19
        ],
        "priority": "medium",
        "details": "A new view for passcode entry needs to be created. When the popup opens, a script should check `chrome.storage.local` for an enabled passcode setting. If enabled, it should then check the time elapsed since the user was last active against a user-configurable delay. If the elapsed time exceeds the configured delay, the lock screen is shown instead of the main dashboard. The user will set their 4-digit passcode and the lock delay (e.g., 'Immediately', 'After 1 minute') in a new section on the Settings page. The passcode must be hashed (e.g., using SHA-256) before being stored. Upon successful entry, the main dashboard view is rendered and the last-active timestamp is updated. Incorrect attempts should display an error message.",
        "testStrategy": "Navigate to the Settings page, set a 4-digit passcode, and configure a 1-minute delay. Close and reopen the popup within the minute to verify the dashboard appears directly. Wait for more than 1 minute, then reopen the popup to verify the lock screen is displayed. Enter the correct passcode to confirm access. Enter an incorrect passcode to verify access is denied. Use developer tools to inspect `chrome.storage.local` and confirm the passcode is a hash and the delay setting and last-active timestamp are stored correctly. Finally, disable the passcode feature and verify the popup opens directly to the dashboard.",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Passcode & Delay Settings UI",
            "description": "Develop the user interface for the passcode settings within the existing Settings page. This includes a toggle switch to enable/disable the feature, a 4-digit passcode input field, a confirmation field, a control to select the lock delay duration, and a save button.",
            "status": "done",
            "dependencies": [],
            "details": "The new section should be added to the Settings view. Passcode inputs must be of type 'password'. Implement client-side validation for the 4-digit passcode. Add a delay control, such as a dropdown menu with options like 'Immediately', 'After 1 minute', 'After 5 minutes', and 'After 15 minutes'.",
            "testStrategy": "Manually verify that the new UI components render correctly on the Settings page. Test the input validation for the passcode. Confirm that the 'Save' button is disabled if the passcode and confirmation fields do not match. Test selecting and saving different delay options."
          },
          {
            "id": 2,
            "title": "Implement Passcode & Delay Storage Logic",
            "description": "Implement the backend logic for the passcode settings. This involves hashing the user's 4-digit passcode using SHA-256 and storing the hash, the enabled/disabled status, and the selected lock delay duration in `chrome.storage.local`.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Integrate a library like `crypto-js` for SHA-256 hashing. When the user saves the settings, store the passcode hash, the enable toggle state, and the selected delay value under keys like `passcodeHash`, `isPasscodeEnabled`, and `lockDelay`.",
            "testStrategy": "After saving a passcode and delay setting, use developer tools to inspect `chrome.storage.local`. Confirm that `isPasscodeEnabled` is set correctly, `passcodeHash` contains a non-plaintext hash, and `lockDelay` stores the selected delay value."
          },
          {
            "id": 3,
            "title": "Build the Passcode Lock Screen View",
            "description": "Create a new, dedicated view component for the passcode lock screen. This view will be displayed when the extension popup is opened and the feature is enabled and the delay has passed.",
            "status": "done",
            "dependencies": [],
            "details": "The view should feature a clear prompt (e.g., 'Enter Passcode'), a 4-digit input field (ideally styled as four separate input boxes or dots), a submit/unlock button, and a designated area to display error messages for incorrect attempts.",
            "testStrategy": "Render the lock screen component in a storybook or isolated test environment. Verify all UI elements are present and correctly styled. Ensure the input mechanism is user-friendly and the error message area is initially hidden."
          },
          {
            "id": 4,
            "title": "Implement Conditional View Logic with Delay",
            "description": "Modify the extension's main entry point to check for the passcode setting and the configured delay. Conditionally render the lock screen based on the time elapsed since the last user activity.",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "In the main popup component's initialization logic, check if `isPasscodeEnabled` is true. If so, retrieve `lockDelay` and `lastActiveTime` from storage. Calculate the time elapsed since `lastActiveTime`. If the elapsed time exceeds `lockDelay` (or if the delay is 'Immediately'), show the lock screen. Otherwise, show the main dashboard and update `lastActiveTime` to the current time. A mechanism to record `lastActiveTime` when the popup closes or becomes inactive is required.",
            "testStrategy": "Test with a 1-minute delay: open, close, and reopen within a minute to verify the dashboard loads directly. Then, wait over a minute and reopen to verify the lock screen appears. Test the 'Immediately' setting. Test disabling the feature entirely."
          },
          {
            "id": 5,
            "title": "Implement Passcode Verification and Timestamp Update",
            "description": "Add the verification logic to the passcode lock screen. When the user submits a passcode, it should be hashed and compared against the stored hash to grant or deny access, and update the last active timestamp upon successful unlock.",
            "status": "done",
            "dependencies": [
              2,
              3
            ],
            "details": "On the lock screen, when the user submits their entry, hash it using the same SHA-256 function. Compare it to the stored `passcodeHash`. If they match, render the main dashboard and update the `lastActiveTime` in `chrome.storage.local` to the current time. If they don't match, display an error message.\n<info added on 2025-07-15T05:01:55.145Z>\nUpon successful authentication, update the last active timestamp in `chrome.storage.local`.\n</info added on 2025-07-15T05:01:55.145Z>",
            "testStrategy": "With the lock screen displayed, enter an incorrect passcode and verify an error message appears. Then, enter the correct passcode and verify the dashboard appears. After a successful unlock, inspect storage to confirm `lastActiveTime` has been updated."
          },
          {
            "id": 6,
            "title": "Implement Lockout Timer Management",
            "description": "Implement the logic to track the last active time of the user and determine if the lockout period has expired. This involves adding a timestamp to `chrome.storage.local` whenever the user successfully authenticates or interacts with the extension.",
            "details": "",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 24
          }
        ]
      }
    ],
    "metadata": {
      "created": "2025-06-29T06:19:55.208Z",
      "updated": "2025-07-15T05:02:01.015Z",
      "description": "Tasks for master context"
    }
  }
}