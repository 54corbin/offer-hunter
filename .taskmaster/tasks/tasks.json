{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Initial Chrome Extension Project Setup",
        "description": "Set up the basic structure for the Google Chrome extension, including the manifest.json file, background scripts, content scripts, and popup HTML/CSS/JS files. This foundational step enables all subsequent development.",
        "details": "Create a `manifest.json` (version 3) defining permissions like `storage`, `activeTab`, and `scripting`. Set up host permissions for `*://*.linkedin.com/*`, `*://*.indeed.com/*`, etc. Create placeholder files: `popup.html`, `popup.js`, `background.js`, and a `content_scripts` directory. Use a modern frontend framework like React or Vue for the popup UI, or start with vanilla JS for simplicity. Initialize a Git repository.",
        "testStrategy": "Load the unpacked extension in Chrome. Verify that the popup window opens when the extension icon is clicked and that the background script logs a message to its console on startup. Ensure no errors appear in the extension management page.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 2,
        "title": "Implement Secure User Profile Data Storage",
        "description": "Implement secure storage for user profile data, including personal information, work experience, education, and skills. This data will be the single source of truth for all extension features.",
        "details": "Use `chrome.storage.local` for storing user data. Define a clear JSON schema for the user profile object, e.g., `{ personalInfo: { name, email, phone }, experience: [{...}], education: [{...}], skills: [...] }`. Create a service module (`storageService.js`) with functions like `getUserProfile()`, `saveUserProfile(data)`, and `updateProfileField(key, value)` to abstract storage operations. All sensitive data should be handled carefully, ensuring it doesn't leak into browser logs.",
        "testStrategy": "Use the extension's background script console to call the service module functions. Save a sample profile object, retrieve it, and assert that the retrieved data matches the saved data. Verify that data persists after closing and reopening the browser.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Develop Profile Management UI",
        "description": "Create the user interface for the profile management page. This allows users to manually input and edit their professional details, which will be used for auto-filling applications.",
        "details": "In `popup.html`, design a form with input fields for all properties defined in the user profile schema (Task 2). This includes sections for personal details, and dynamic lists for work experience and education where users can add or remove entries. On input change, automatically save the data using the `storageService.js`. Populate the form with existing data when the popup is opened.",
        "testStrategy": "Open the extension popup. Manually fill in all fields. Close and reopen the popup to ensure all data is correctly loaded and displayed. Edit a field and verify the change is persisted. Test adding and removing items from dynamic lists like work experience.",
        "priority": "high",
        "dependencies": [
          1,
          2
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Resume Parsing for Profile Population",
        "description": "Implement functionality to parse uploaded resumes in PDF and DOCX formats and use the extracted text to pre-fill the user's profile form.",
        "details": "Add a file input (`<input type=\"file\" accept=\".pdf,.docx\">`) to the profile UI. Use client-side libraries to handle parsing: `pdf-js-dist` for PDFs and `mammoth.js` for DOCX. When a file is uploaded, read its content and extract structured information (e.g., using regex or simple heuristics to find sections like 'Experience', 'Education', 'Skills'). Populate the corresponding fields in the profile UI for the user to review and save.",
        "testStrategy": "Upload various sample resumes in both PDF and DOCX formats. Verify that text is extracted successfully. Check if the profile fields (name, email, job titles, etc.) are populated with reasonable accuracy. Ensure the UI handles parsing errors gracefully.",
        "priority": "medium",
        "dependencies": [
          3
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Create Content Script for Application Form Detection",
        "description": "Develop a content script that can be injected into supported job platforms to detect and identify application form fields.",
        "details": "Configure the `manifest.json` to inject a content script (`formDetector.js`) into pages matching application URLs on LinkedIn, Indeed, etc. The script will scan the DOM for `<form>` elements and common input field selectors (e.g., `input[name*='name']`, `textarea[id*='experience']`, `[aria-label*='phone']`). Create a mapping configuration that defines selectors for each supported site.",
        "testStrategy": "Navigate to job application pages on LinkedIn and Indeed. Verify the content script is injected. Use `console.log` to output the detected form fields to the browser's developer console. Manually check if key fields like 'First Name', 'Email', and 'Resume Upload' are correctly identified.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement Automated Form Filling Logic",
        "description": "Implement the core logic to automatically fill detected form fields with data from the user's stored profile.",
        "details": "The content script will message the background script to fetch the user profile from `chrome.storage`. Upon receiving the data, it will iterate through the detected form fields and populate them with the corresponding profile information. For example, `document.querySelector('#firstName').value = userProfile.personalInfo.firstName`. Add a small delay between filling fields to mimic human behavior and avoid bot detection.",
        "testStrategy": "With a pre-filled user profile, navigate to a job application page. Trigger the auto-fill process (e.g., via a button injected by the content script). Verify that all corresponding form fields are populated correctly with the data from the user profile. Test on multiple job postings on each supported platform.",
        "priority": "high",
        "dependencies": [
          2,
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 7,
        "title": "Develop UI for Triggering and Reviewing Auto-Fill",
        "description": "Create a UI element, such as a floating button or a banner, that allows the user to trigger, review, and confirm the auto-filled information before submission.",
        "details": "The content script will inject a floating button (e.g., with the extension's logo) onto the page when an application form is detected. Clicking this button initiates the auto-fill process. After filling, the script can highlight the modified fields with a colored border. The UI should clearly state that the form has been filled and that the user should review it.",
        "testStrategy": "Navigate to an application page. Confirm the 'Auto-fill' button appears. Click it and verify fields are filled and highlighted. Manually edit a highlighted field and ensure the change is not overwritten. The button's state should update (e.g., to 'Filled') after the action.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Integrate with an LLM API Service",
        "description": "Set up a secure service to communicate with a Large Language Model (LLM) API for content generation tasks. This includes managing API keys securely.",
        "details": "Create a module in the background script (`llmService.js`). This service will have a function, e.g., `generateContent(prompt)`, that uses the `fetch` API to make POST requests to an LLM provider (e.g., OpenAI, Google AI). The user's API key will be stored securely using `chrome.storage.local` after being entered in the extension's settings page. The service must handle API errors and rate limits.",
        "testStrategy": "In the extension's settings, add an input for the LLM API key and save it. From the background script console, call the `generateContent` function with a simple prompt like 'say hello'. Verify that a successful 200 OK response is received from the LLM API and the content is returned.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Job Description Scraping",
        "description": "Enhance the content script to accurately scrape the full job title and description from the job posting page.",
        "details": "The content script will use site-specific selectors to find and extract the text content of the job title and the main job description block. This data is crucial context for the LLM. The script should clean the extracted text by removing unwanted HTML tags and whitespace. This information will be temporarily stored or passed directly to the background script when needed.",
        "testStrategy": "Navigate to several job pages on each supported platform. Use the developer console to trigger the scraping function and log the extracted job title and description. Manually compare the output with the page content to ensure accuracy and completeness.",
        "priority": "high",
        "dependencies": [
          5
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Implement AI-Powered Answer Generation",
        "description": "Leverage the LLM to generate tailored answers for open-ended questions on application forms, based on the user's profile and the job description.",
        "details": "The content script will identify open-ended question fields (e.g., `<textarea>`). It will inject a 'Generate Answer' button next to them. On click, it will send the question text (e.g., from the `label`), the scraped job description, and the user's profile to the `llmService`. The prompt will be structured like: 'Based on my profile (profile...) and the job description (job...), answer this question: (question...)'. The generated text is then inserted into the textarea.",
        "testStrategy": "Find an application with a question like 'Why are you a good fit for this role?'. Click the 'Generate Answer' button. Verify that the LLM-generated response is relevant, uses information from both the profile and job description, and is inserted into the correct field.",
        "priority": "high",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 11,
        "title": "Implement AI-Powered Cover Letter Generation",
        "description": "Create a feature to generate a custom cover letter based on the job description and the user's profile.",
        "details": "Add a 'Generate Cover Letter' button to the extension's main popup UI. When on a job page, clicking this button will trigger the `llmService`. The service will be called with a prompt combining the user's full profile and the scraped job description, asking it to write a professional cover letter. The generated text will be displayed in a modal or new tab, with options to copy or save.",
        "testStrategy": "Navigate to a job posting. Open the extension popup and click 'Generate Cover Letter'. Review the generated letter for quality, relevance, and personalization. It should clearly reference the user's skills/experience and the requirements in the job description.",
        "priority": "medium",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 12,
        "title": "Develop Extension Dashboard UI",
        "description": "Design and build the main dashboard UI for the extension's popup, serving as the central hub for all features.",
        "details": "Develop the main view for `popup.html`. This dashboard should provide clear navigation to different sections: 'Profile', 'Recommended Jobs', 'Application History', and 'Settings'. It should have a clean, intuitive layout that presents key information at a glance. This is the primary user interaction point, so usability is key.",
        "testStrategy": "Open the extension popup. Verify that the dashboard layout is rendered correctly. Test navigation between the different sections/tabs. The UI should be responsive and visually appealing.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 13,
        "title": "Implement AI Job-to-Profile Relevance Analysis",
        "description": "Implement the logic to analyze a job description against the user's profile and determine a relevance score.",
        "details": "Create a function that can be triggered from the content script. This function sends the user's profile (skills, experience titles) and the scraped job description to the LLM service. The prompt will ask the LLM to act as a recruiter, compare the two, and return a relevance score (e.g., 1-100) and a brief summary of why it's a match or not. This logic will power the job recommendations.",
        "testStrategy": "Manually trigger the analysis function with a known good-fit job and a known bad-fit job. Check the returned score and summary. The good fit should have a high score and relevant summary, while the bad fit should have a low score.",
        "priority": "medium",
        "dependencies": [
          2,
          8,
          9
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 14,
        "title": "Display AI-Powered Job Recommendations",
        "description": "Display a list of recommended jobs within the extension's dashboard, ranked by the AI-driven relevance score.",
        "details": "This feature requires a mechanism to discover jobs (e.g., by scraping a search results page or analyzing jobs the user clicks on). For each discovered job, run the relevance analysis (Task 13). Store the job title, link, and relevance score in `chrome.storage`. The 'Recommended Jobs' section of the dashboard will fetch and display this list, sorted from highest to lowest relevance.",
        "testStrategy": "Browse a job search results page. Verify that the extension identifies multiple jobs and analyzes them. Open the dashboard and check the 'Recommended Jobs' list. The jobs should be present and correctly ranked by their relevance score.",
        "priority": "low",
        "dependencies": [
          12,
          13
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 15,
        "title": "Implement Application Tracking",
        "description": "Implement a system to track the jobs a user has applied to using the extension, storing the job title, company, and date applied.",
        "details": "After a user successfully uses the auto-fill feature and a form submission is detected (e.g., by observing a URL change to a 'success' page or the submit button disappearing), the content script will prompt the user: 'Track this application?'. If confirmed, the job title, company, URL, and current date are saved to a dedicated list in `chrome.storage.local`.",
        "testStrategy": "Apply to a job using the auto-fill feature. On the confirmation page, ensure the 'Track this application?' prompt appears. Click 'Yes' and then check `chrome.storage` via the background console to confirm the application details were saved correctly.",
        "priority": "medium",
        "dependencies": [
          6
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 16,
        "title": "Develop UI for Application History",
        "description": "Create a UI section within the dashboard to display the list of jobs the user has applied for.",
        "details": "Add an 'Application History' tab or section to the dashboard UI. This section will fetch the list of tracked applications from `chrome.storage` and display it in a clear, reverse chronological list. Each entry should show the job title, company, and date applied, and include a link to the original job posting.",
        "testStrategy": "After tracking several applications, open the dashboard and navigate to the 'Application History' section. Verify that all tracked jobs are listed correctly with the right information and in the correct order. Test that the links navigate to the correct job pages.",
        "priority": "medium",
        "dependencies": [
          12,
          15
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 17,
        "title": "Create Extension Settings Page",
        "description": "Create a settings page within the extension where users can manage their LLM API key and other preferences.",
        "details": "Build a 'Settings' view accessible from the main dashboard. This page will include an input field for the user to enter and save their LLM API key. It should also include toggles for enabling/disabling major features like auto-fill or AI recommendations. All settings will be saved to `chrome.storage.local`.",
        "testStrategy": "Navigate to the settings page. Enter an API key and save it. Close and reopen the popup, return to settings, and verify the key is still there (masked, e.g., `sk-****...1234`). Toggle a feature off, and confirm that the corresponding functionality is disabled.",
        "priority": "medium",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 18,
        "title": "Ensure Cross-Platform Compatibility",
        "description": "Systematically test and refine content scripts to ensure compatibility and correct functionality across all supported job platforms: LinkedIn, Indeed, Glassdoor, and ZipRecruiter.",
        "details": "Create a testing checklist for each platform. For each site, test: 1. Form detection. 2. Auto-fill accuracy. 3. Job description scraping. 4. AI answer generation button injection. This will likely require creating site-specific selector maps and logic to handle variations in page structure. Update the `host_permissions` in the manifest as needed.",
        "testStrategy": "Go through a full application flow on at least two different job postings on each of the four target platforms. Document any failures or incorrect behavior in a bug tracking system. The task is complete when all core features work reliably on all supported sites.",
        "priority": "high",
        "dependencies": [
          6,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 19,
        "title": "Security Audit and Hardening",
        "description": "Conduct a thorough review of data handling and storage practices to ensure all user data is secure. This includes encrypting sensitive information where necessary.",
        "details": "Review all `chrome.storage` usage. While `chrome.storage` is sandboxed, consider adding a layer of client-side encryption for the LLM API key before storing it. Use a library like `crypto-js`. Ensure all communication with external APIs (the LLM) uses HTTPS. Sanitize any data displayed in the UI to prevent XSS attacks.",
        "testStrategy": "Perform a code review focused on security. Check network requests in the browser's developer tools to ensure they use HTTPS. Manually inspect the contents of `chrome.storage` to confirm sensitive data like API keys are not stored in plaintext. Attempt to inject scripts into profile fields to test for XSS vulnerabilities.",
        "priority": "high",
        "dependencies": [
          2,
          8
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 20,
        "title": "Performance Optimization",
        "description": "Analyze and optimize the extension's performance to ensure it does not slow down the user's browsing experience. Focus on lightweight content scripts and responsive AI generation.",
        "details": "Use the Chrome DevTools Performance profiler to measure the impact of content scripts on page load and interactivity. Optimize DOM scanning by using efficient selectors and avoiding frequent, heavy computations on the main thread. For AI features, ensure the UI shows a loading state immediately so the user knows something is happening, preventing the perception of a frozen page.",
        "testStrategy": "With the extension enabled, browse the supported job sites and measure page load times and CPU usage, comparing them to browsing with the extension disabled. The difference should be negligible. Time how long it takes for AI-generated content to appear after clicking the button; it should be within a few seconds.",
        "priority": "medium",
        "dependencies": [
          6,
          10
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 21,
        "title": "Create Extension Icons and Visual Assets",
        "description": "Design and create all necessary visual assets for the extension, including icons for the toolbar, the Chrome Web Store, and any images used within the UI.",
        "details": "Create a main extension logo. Generate a set of icons in required sizes (16x16, 32x32, 48x48, 128x128) for the `manifest.json`. Design any other icons or simple illustrations needed for the dashboard UI to improve usability. Ensure all assets are optimized for size.",
        "testStrategy": "Load the extension with the new icons. Verify the toolbar icon is clear and correctly sized. Check that all icons within the UI are displayed properly. Ensure the 128x128 icon looks good on the extension management page.",
        "priority": "low",
        "dependencies": [
          12
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 22,
        "title": "Package and Prepare for Chrome Web Store Submission",
        "description": "Prepare the extension for submission to the Chrome Web Store, including creating the final packaged file, writing a description, taking screenshots, and drafting a privacy policy.",
        "details": "Write a compelling description for the Chrome Web Store listing, highlighting the key benefits (time-saving, AI-powered). Take high-quality screenshots of the extension in action (e.g., profile page, auto-filling a form, AI-generated answer). Draft a clear privacy policy explaining what data is collected and how it is used and stored. Package the extension into a .zip file for upload.",
        "testStrategy": "Review the generated package and store listing materials against the Chrome Web Store developer guidelines. Have a peer read the description and privacy policy for clarity. The task is complete when the .zip file and all marketing assets are ready for upload.",
        "priority": "high",
        "dependencies": [
          18,
          19,
          20,
          21
        ],
        "status": "done",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-06-29T06:19:55.208Z",
      "updated": "2025-06-29T08:08:22.138Z",
      "description": "Tasks for master context"
    }
  }
}